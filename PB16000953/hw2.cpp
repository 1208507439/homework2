#include"opencv2/opencv.hpp"
#include"cv.h"
#include<iostream>
using namespace cv;
using namespace std;
#define MY_FAIL 0
#define MY_OK 1

//三角函数打表
float sin_map[360]={
	0.000000,0.017452,
	0.034899,0.052336,
	0.069756,0.087156,
	0.104528,0.121869,
	0.139173,0.156434,
	0.173648,0.190809,
	0.207912,0.224951,
	0.241922,0.258819,
	0.275637,0.292372,
	0.309017,0.325568,
	0.342020,0.358368,
	0.374607,0.390731,
	0.406737,0.422618,
	0.438371,0.453990,
	0.469472,0.484810,
	0.500000,0.515038,
	0.529919,0.544639,
	0.559193,0.573576,
	0.587785,0.601815,
	0.615661,0.629320,
	0.642788,0.656059,
	0.669131,0.681998,
	0.694658,0.707107,
	0.719340,0.731354,
	0.743145,0.754710,
	0.766044,0.777146,
	0.788011,0.798636,
	0.809017,0.819152,
	0.829038,0.838671,
	0.848048,0.857167,
	0.866025,0.874620,
	0.882948,0.891007,
	0.898794,0.906308,
	0.913545,0.920505,
	0.927184,0.933580,
	0.939693,0.945519,
	0.951057,0.956305,
	0.961262,0.965926,
	0.970296,0.974370,
	0.978148,0.981627,
	0.984808,0.987688,
	0.990268,0.992546,
	0.994522,0.996195,
	0.997564,0.998630,
	0.999391,0.999848,
	1.000000,0.999848,
	0.999391,0.998630,
	0.997564,0.996195,
	0.994522,0.992546,
	0.990268,0.987688,
	0.984808,0.981627,
	0.978148,0.974370,
	0.970296,0.965926,
	0.961262,0.956305,
	0.951057,0.945519,
	0.939693,0.933580,
	0.927184,0.920505,
	0.913545,0.906308,
	0.898794,0.891007,
	0.882948,0.874620,
	0.866025,0.857167,
	0.848048,0.838671,
	0.829038,0.819152,
	0.809017,0.798636,
	0.788011,0.777146,
	0.766044,0.754710,
	0.743145,0.731354,
	0.719340,0.707107,
	0.694658,0.681998,
	0.669131,0.656059,
	0.642788,0.629320,
	0.615661,0.601815,
	0.587785,0.573576,
	0.559193,0.544639,
	0.529919,0.515038,
	0.500000,0.484810,
	0.469472,0.453990,
	0.438371,0.422618,
	0.406737,0.390731,
	0.374607,0.358368,
	0.342020,0.325568,
	0.309017,0.292372,
	0.275637,0.258819,
	0.241922,0.224951,
	0.207912,0.190809,
	0.173648,0.156434,
	0.139173,0.121869,
	0.104528,0.087156,
	0.069756,0.052336,
	0.034899,0.017452,
	0.000000,-0.017452,
	-0.034899,-0.052336,
	-0.069756,-0.087156,
	-0.104528,-0.121869,
	-0.139173,-0.156434,
	-0.173648,-0.190809,
	-0.207912,-0.224951,
	-0.241922,-0.258819,
	-0.275637,-0.292372,
	-0.309017,-0.325568,
	-0.342020,-0.358368,
	-0.374607,-0.390731,
	-0.406737,-0.422618,
	-0.438371,-0.453990,
	-0.469472,-0.484810,
	-0.500000,-0.515038,
	-0.529919,-0.544639,
	-0.559193,-0.573576,
	-0.587785,-0.601815,
	-0.615661,-0.629320,
	-0.642788,-0.656059,
	-0.669131,-0.681998,
	-0.694658,-0.707107,
	-0.719340,-0.731354,
	-0.743145,-0.754710,
	-0.766044,-0.777146,
	-0.788011,-0.798636,
	-0.809017,-0.819152,
	-0.829038,-0.838671,
	-0.848048,-0.857167,
	-0.866025,-0.874620,
	-0.882948,-0.891007,
	-0.898794,-0.906308,
	-0.913545,-0.920505,
	-0.927184,-0.933580,
	-0.939693,-0.945519,
	-0.951057,-0.956305,
	-0.961262,-0.965926,
	-0.970296,-0.974370,
	-0.978148,-0.981627,
	-0.984808,-0.987688,
	-0.990268,-0.992546,
	-0.994522,-0.996195,
	-0.997564,-0.998630,
	-0.999391,-0.999848,
	-1.000000,-0.999848,
	-0.999391,-0.998630,
	-0.997564,-0.996195,
	-0.994522,-0.992546,
	-0.990268,-0.987688,
	-0.984808,-0.981627,
	-0.978148,-0.974370,
	-0.970296,-0.965926,
	-0.961262,-0.956305,
	-0.951057,-0.945519,
	-0.939693,-0.933580,
	-0.927184,-0.920505,
	-0.913545,-0.906308,
	-0.898794,-0.891007,
	-0.882948,-0.874620,
	-0.866025,-0.857167,
	-0.848048,-0.838671,
	-0.829038,-0.819152,
	-0.809017,-0.798636,
	-0.788011,-0.777146,
	-0.766044,-0.754710,
	-0.743145,-0.731354,
	-0.719340,-0.707107,
	-0.694658,-0.681998,
	-0.669131,-0.656059,
	-0.642788,-0.629320,
	-0.615661,-0.601815,
	-0.587785,-0.573576,
	-0.559193,-0.544639,
	-0.529919,-0.515038,
	-0.500000,-0.484810,
	-0.469472,-0.453990,
	-0.438371,-0.422618,
	-0.406737,-0.390731,
	-0.374607,-0.358368,
	-0.342020,-0.325568,
	-0.309017,-0.292372,
	-0.275637,-0.258819,
	-0.241922,-0.224951,
	-0.207912,-0.190809,
	-0.173648,-0.156434,
	-0.139173,-0.121869,
	-0.104528,-0.087156,
	-0.069756,-0.052336,
	-0.034899,-0.017452
};
float cos_map[360] = {
	1.000000,0.999848,
	0.999391,0.998630,
	0.997564,0.996195,
	0.994522,0.992546,
	0.990268,0.987688,
	0.984808,0.981627,
	0.978148,0.974370,
	0.970296,0.965926,
	0.961262,0.956305,
	0.951057,0.945519,
	0.939693,0.933580,
	0.927184,0.920505,
	0.913545,0.906308,
	0.898794,0.891007,
	0.882948,0.874620,
	0.866025,0.857167,
	0.848048,0.838671,
	0.829038,0.819152,
	0.809017,0.798636,
	0.788011,0.777146,
	0.766044,0.754710,
	0.743145,0.731354,
	0.719340,0.707107,
	0.694658,0.681998,
	0.669131,0.656059,
	0.642788,0.629320,
	0.615661,0.601815,
	0.587785,0.573576,
	0.559193,0.544639,
	0.529919,0.515038,
	0.500000,0.484810,
	0.469472,0.453990,
	0.438371,0.422618,
	0.406737,0.390731,
	0.374607,0.358368,
	0.342020,0.325568,
	0.309017,0.292372,
	0.275637,0.258819,
	0.241922,0.224951,
	0.207912,0.190809,
	0.173648,0.156434,
	0.139173,0.121869,
	0.104528,0.087156,
	0.069756,0.052336,
	0.034899,0.017452,
	0.000000,-0.017452,
	-0.034899,-0.052336,
	-0.069756,-0.087156,
	-0.104528,-0.121869,
	-0.139173,-0.156434,
	-0.173648,-0.190809,
	-0.207912,-0.224951,
	-0.241922,-0.258819,
	-0.275637,-0.292372,
	-0.309017,-0.325568,
	-0.342020,-0.358368,
	-0.374607,-0.390731,
	-0.406737,-0.422618,
	-0.438371,-0.453990,
	-0.469472,-0.484810,
	-0.500000,-0.515038,
	-0.529919,-0.544639,
	-0.559193,-0.573576,
	-0.587785,-0.601815,
	-0.615661,-0.629320,
	-0.642788,-0.656059,
	-0.669131,-0.681998,
	-0.694658,-0.707107,
	-0.719340,-0.731354,
	-0.743145,-0.754710,
	-0.766044,-0.777146,
	-0.788011,-0.798636,
	-0.809017,-0.819152,
	-0.829038,-0.838671,
	-0.848048,-0.857167,
	-0.866025,-0.874620,
	-0.882948,-0.891007,
	-0.898794,-0.906308,
	-0.913545,-0.920505,
	-0.927184,-0.933580,
	-0.939693,-0.945519,
	-0.951057,-0.956305,
	-0.961262,-0.965926,
	-0.970296,-0.974370,
	-0.978148,-0.981627,
	-0.984808,-0.987688,
	-0.990268,-0.992546,
	-0.994522,-0.996195,
	-0.997564,-0.998630,
	-0.999391,-0.999848,
	-1.000000,-0.999848,
	-0.999391,-0.998630,
	-0.997564,-0.996195,
	-0.994522,-0.992546,
	-0.990268,-0.987688,
	-0.984808,-0.981627,
	-0.978148,-0.974370,
	-0.970296,-0.965926,
	-0.961262,-0.956305,
	-0.951057,-0.945519,
	-0.939693,-0.933580,
	-0.927184,-0.920505,
	-0.913545,-0.906308,
	-0.898794,-0.891007,
	-0.882948,-0.874620,
	-0.866025,-0.857167,
	-0.848048,-0.838671,
	-0.829038,-0.819152,
	-0.809017,-0.798636,
	-0.788011,-0.777146,
	-0.766044,-0.754710,
	-0.743145,-0.731354,
	-0.719340,-0.707107,
	-0.694658,-0.681998,
	-0.669131,-0.656059,
	-0.642788,-0.629320,
	-0.615661,-0.601815,
	-0.587785,-0.573576,
	-0.559193,-0.544639,
	-0.529919,-0.515038,
	-0.500000,-0.484810,
	-0.469472,-0.453990,
	-0.438371,-0.422618,
	-0.406737,-0.390731,
	-0.374607,-0.358368,
	-0.342020,-0.325568,
	-0.309017,-0.292372,
	-0.275637,-0.258819,
	-0.241922,-0.224951,
	-0.207912,-0.190809,
	-0.173648,-0.156434,
	-0.139173,-0.121869,
	-0.104528,-0.087156,
	-0.069756,-0.052336,
	-0.034899,-0.017452,
	-0.000000,0.017452,
	0.034899,0.052336,
	0.069756,0.087156,
	0.104528,0.121869,
	0.139173,0.156434,
	0.173648,0.190809,
	0.207912,0.224951,
	0.241922,0.258819,
	0.275637,0.292372,
	0.309017,0.325568,
	0.342020,0.358368,
	0.374607,0.390731,
	0.406737,0.422618,
	0.438371,0.453990,
	0.469472,0.484810,
	0.500000,0.515038,
	0.529919,0.544639,
	0.559193,0.573576,
	0.587785,0.601815,
	0.615661,0.629320,
	0.642788,0.656059,
	0.669131,0.681998,
	0.694658,0.707107,
	0.719340,0.731354,
	0.743145,0.754710,
	0.766044,0.777146,
	0.788011,0.798636,
	0.809017,0.819152,
	0.829038,0.838671,
	0.848048,0.857167,
	0.866025,0.874620,
	0.882948,0.891007,
	0.898794,0.906308,
	0.913545,0.920505,
	0.927184,0.933580,
	0.939693,0.945519,
	0.951057,0.956305,
	0.961262,0.965926,
	0.970296,0.974370,
	0.978148,0.981627,
	0.984808,0.987688,
	0.990268,0.992546,
	0.994522,0.996195,
	0.997564,0.998630,
	0.999391,0.999848
};

//为防止找到的圆过多引起越界现象，用链表储存找到的圆
typedef struct CircleJudge
{
	//数据域
	int xx;//圆心横坐标
	int yy;//圆心纵坐标
	int rr;//圆半径
	int ave[3];//储存不同通道的差分值
	int ave_max;//三通道差分最大值
	//指针域
	CircleJudge *next;
}CircleJudge;

//函数说明：
//返回三个数的最大值
int channel_diff_max(int a, int b, int c)
{
	if (a > b)
	{
		if (a > c)
			return a;
		else 
			return c;
	}
	else
	{
		if (b > c)
			return b;
		else
			return c;
	}
}//end channel_diff_max

//函数说明
//交换两个CircleJudge结构体变量中的数据域
void my_swap(CircleJudge*p,CircleJudge*q)
{

	int temp;
	temp = p->xx;
	p->xx = q->xx;
	q->xx = temp;

	temp = p->yy;
	p->yy = q->yy;
	q->yy = temp;

	temp = p->rr;
	p->rr = q->rr;
	q->rr = temp;

	temp = p->ave_max;
	p->ave_max = q->ave_max;
	q->ave_max = temp;

	temp = p->ave[0];
	p->ave[0] = q->ave[0];
	q->ave[0] = p->ave[0];

	temp = p->ave[1];
	p->ave[1] = q->ave[1];
	q->ave[1] = p->ave[1];

	temp = p->ave[2];
	p->ave[2] = q->ave[2];
	q->ave[2] = p->ave[2];

}



//功能说明：找到图像中所有圆心在图像内的圆，得到中心点和半径
//colorImg：用来搜索圆形目标的彩色图像
//min_radius：需要搜索的圆的最小半径
//max_radius：需要搜索的圆的最大半径
//min_center_dist：找到的圆心之间的最小距离
//min_radius_dist：同心圆半径之间的最小差距
//max_circle_diff：阈值，圆周差分值低于此阈值，不是圆
//x：数组，存储所有的圆的中心点x坐标
//y：数组，存储所有的圆的中心点y坐标
//radius：数组，存储所有的圆的半径值
//circle_cnt：图像中找到的圆的数目
//max_circle：外部传入参数，圆的数目上限。如果图像中圆的数目超过此参数，根据差分值由大到小进行排序
//返回值：MY_OK或者MY_FAIL

int ustc_Find_Circles_By_Difference(
	Mat colorImg,
	int min_radius,
	int max_radius,
	int min_center_dist,
	int min_radius_dist,
	int max_circle_diff,
	int* x,
	int* y,
	int* radius,
	int* circle_cnt,
	int max_circle)
{
	//********************参数合法性检查**********************

	//判断图像是否为空
	if (NULL == colorImg.data)
	{
		cout << "The Image is NULL" << endl;
		return MY_FAIL;
	}
	//检验通道数是否正确
	if (colorImg.channels() != 3)
	{
		cout << "The channels of the Image is ERRPR" << endl;
		return MY_FAIL;
	}
	//检验给定圆的半径范围是否正确
	if (min_radius <= 5 || min_radius > max_radius)
	{
		cout << "The Input Radius ERROR" << endl;
		return MY_FAIL;
	}
	//检验储存位置是否为空
	if (NULL == x || NULL == y || NULL == radius || NULL == circle_cnt)
	{
		cout << "x,y,radius,or len is NULL\n" << endl;
		return MY_FAIL;
	}
	//检查给定的阈值是否合法
	if (max_circle_diff < 0 || max_circle_diff>255)
	{
		cout << "the value of max_circle_diff is illegal" << endl;
		return MY_FAIL;
	}
	//检查给定的最小圆心距离和最小半径差是否合法
	if (min_center_dist < 0 || min_radius_dist < 0)
	{
		cout << "the value of min_center_dist or min_radius_dist is illegal" << endl;
		return MY_FAIL;
	}
	//检测给定的最大圆数目限制是否正确
	if (max_circle < 0)
	{
		cout << "Input max_circle ERROR" << endl;
	}
	int width = colorImg.cols;
	int height = colorImg.rows;
	//*********************参数合法性检查结束**************************



	//创建图像数组用以储存彩色图分离通道后的单通道图
	Mat bgr[3];
	//通道分离
	split(colorImg, bgr);

	//定义不同半径和角度下相对圆心的横纵坐标x，y表
	int(*r_theta_xx)[360] = new int[max_radius + 5 + 1][360];
	int(*r_theta_yy)[360] = new int[max_radius + 5 + 1][360];
	//int *xx = new int[max_circle];
	//int yy[50000] = {0};
	//int rr[50000] = {0};

	//此变量当前链表中储存的圆的数目
	int ll = 0;
	//半径相关参量
	int r_bottom = min_radius - 5, r_top = max_radius + 5, r_range = max_radius - min_radius;
	//非极大值抑制相关参量的平方，避免在循环内部调用abs
	int square_min_center_dist = min_center_dist*min_center_dist;
	int square_min_radius_dist = min_radius_dist*min_radius_dist;


	//建立圆周上的点相对圆心的坐标表以备使用，避免重复计算
	for (int r = r_bottom; r <= r_top; r++)
	{
		for (int theta = 0; theta < 360; theta++)
		{
			r_theta_xx[r][theta] = r *cos_map[theta];
			r_theta_yy[r][theta] = r *sin_map[theta];
		}
	}
	//***************找圆过程*******************
	//分配内存空间储存图像上一个点，在不同半径下三个通道的圆周差分平均值
	int *pixAve_b = new int[r_top + 1];
	int *pixAve_g = new int[r_top + 1];
	int *pixAve_r = new int[r_top + 1];

	//建立储存找圆结果的链表
	CircleJudge *head = new CircleJudge;
	CircleJudge *p = head;

	for (int row_y = 0; row_y < height; row_y++)
	{
		for (int col_x = 0; col_x < width; col_x++)
		{

			for (int rad = r_bottom; rad <= r_top; rad++)
			{
				int count = 0;//计数器，统计圆周上落在图像内部的点
				//圆周上三个通道的像素值之和
				int pix_sum_b = 0;
				int pix_sum_g = 0;
				int pix_sum_r = 0;

				for (int theta = 0; theta < 360; theta++)
				{
					//当前圆周上点的坐标
					int pos_x = col_x + r_theta_xx[rad][theta];
					int pos_y = row_y + r_theta_yy[rad][theta];
					//跳过圆周上处于图像外的点
					if (pos_x < 0 || pos_y < 0 || pos_x >= width || pos_y >= height)
					{
						continue;
					}//end if

					 //圆周上点在图像数组的储存位置
					int pos = width*pos_y + pos_x;
					//int pos = 3*(width*pos_y + pos_x);

					//记录各个通道的像素值
					int pix_b = bgr[0].data[pos];
					int pix_g = bgr[1].data[pos];
					int pix_r = bgr[2].data[pos];
					//int pix_b = colorImg.data[pos];
					//int pix_g = colorImg.data[pos+1];
					//int pix_r = colorImg.data[pos + 2];

					//像素值累加
					pix_sum_b += pix_b;
					pix_sum_g += pix_g;
					pix_sum_r += pix_r;
					//每记录1个点，像素点计数器+1
					count++;
				}//end theta

				//计算圆周上像素均值，排除半径参数过大，使得count为0的错误情形
				if (count > 0)
				{
					pixAve_b[rad] = pix_sum_b / count;
					pixAve_g[rad] = pix_sum_g / count;
					pixAve_r[rad] = pix_sum_r / count;
				}
				else if (0 == count)//像素点均在图像外，应予以排除
				{
					pixAve_b[rad] = 0;
					pixAve_g[rad] = 0;
					pixAve_r[rad] = 0;
				}
			}//end r

			//从最小半径到最大半径依次判断是否符合圆周差分法找圆的要求
			for (int r_judge = min_radius; r_judge <= max_radius; r_judge++)
			{
				//内外圆半径
				int in_r = r_judge - 5;
				int out_r = r_judge + 5;
				//计算3个通道的差分值
				int in_out_diff_b = abs(pixAve_b[in_r] - pixAve_b[out_r]);
				int in_out_diff_g = abs(pixAve_g[in_r] - pixAve_g[out_r]);
				int in_out_diff_r = abs(pixAve_r[in_r] - pixAve_r[out_r]);

				//判断是否为圆
				if (in_out_diff_b > max_circle_diff
					|| in_out_diff_g > max_circle_diff
					|| in_out_diff_r > max_circle_diff
					)
				{
					p->next = new CircleJudge;
					p = p->next;
					p->xx = col_x;
					p->yy = row_y;
					p->rr = r_judge;
					p->ave[0] = in_out_diff_b;
					p->ave[1] = in_out_diff_g;
					p->ave[2] = in_out_diff_r;
					ll++;
				}//end if

				 //阈值防护，阈值过低圆的数量过大会使得结果不正确
				if (ll > 15000) 
				{
					cout << "找到的圆太多了，需要调高阈值以获得正确的结果" << endl;
					return MY_FAIL;
				}
			}//end r
		}//end x
	}//endy
	//尾节点的指针域赋空值

	

	p->next = NULL;



/************************以下未考虑非极大值抑制要优先保留差分值大的圆*****************************/
/******************修改时间2017.10.10************************/

	//由于循环中仅是以前后比较方式进行非极大值抑制，排除了一部分圆，可能会有圆心离得很近的圆逃过一劫
	//需要再次进行精确的非极大值抑制
	/*非极大值抑制过程*/
	//找圆结果按x从小到大排序   选择排序法
	/*for (p = head->next; p != NULL; p = p->next)
	{
		CircleJudge*t = p;//用于标记横坐标最大的节点
		int max = p->xx;
		for (CircleJudge*q1 = p->next; q1 != NULL; q1 = q1->next)
		{
			if (max < q1->xx)
			{
				t = q1;
				max = q1->xx;
			}
		}
		if (t != p)
			my_swap(t, p);
	}

	//按照x顺序进行非极大值抑制
	CircleJudge*q = head->next;
	for (p = head; q != NULL; )
	{
		int d_x = q->xx - p->xx;
		int d_y = q->yy - p->yy;
		int d_r = q->rr - p->rr;
		if (d_r*d_r <= square_min_radius_dist
			&& d_x*d_x + d_y*d_y <= square_min_center_dist)//不满足非极大值抑制条件
		{//删除结点
			p->next = q->next;
			delete q;
			q = p->next;
			ll--;//找到的圆数目-1
			continue;//此时q，p不需要移动
		}
		p = p->next;
		q = q->next;
	}
	
	 //找圆结果按y从小到大排序   选择排序法
	for (p = head->next; p != NULL; p = p->next)
	{
		CircleJudge*t = p;//用于标记纵坐标最大的节点
		int max = p->yy;
		for (CircleJudge*q1 = p->next; q1 != NULL; q1 = q1->next)
		{
			if (max < q1->yy)
			{
				t = q1;
				max = q1->yy;
			}
		}
		if (t != p)
			my_swap(t, p);
	}

	//按照y非极大值抑制
	 q = head->next;
	for (p = head; q != NULL; )
	{
		int d_x = q->xx - p->xx;
		int d_y = q->yy - p->yy;
		int d_r = q->rr - p->rr;
		if (d_r*d_r <= square_min_radius_dist
			&& d_x*d_x + d_y*d_y <= square_min_center_dist)//不满足非极大值抑制条件
		{//删除结点
			p->next = q->next;
			delete q;
			q = p->next;
			ll--;//找到的圆数目-1
			continue;//此时q，p不需要移动
		}
		p = p->next;
		q = q->next;
	}*/
/**************************************************************/


	
	
	//遍历所有节点，计算三个通道中最大的差分值作为排序的标准
	for (p = head->next; p != NULL; p = p->next)
	{
		p->ave_max = channel_diff_max(p->ave[0], p->ave[1], p->ave[2]);
	}

	//按三个通道中最大的差分值从大到小排序   选择排序法
	int count = 0;//对满足的元素进行计数
	for (p = head->next; p != NULL; p = p->next)
	{
		if (count >= max_circle)
			break;//对于超过数目要求的结果，我们只要得到的规定数目的排序结果即可
		CircleJudge*t1=p;//标记当前未排好序的第一个节点
		int max = p->ave_max;
		/*************排序小循环************/
		for (CircleJudge*q1 = p->next; q1 != NULL; q1 = q1->next)
		{
			
			if (max < q1->ave_max)
			{
				t1 = q1;//标记差分值最大的节点
				max = q1->ave_max;
			}
		}
		if(t1!=p)
		my_swap(t1, p);//交换数据域
		/*************排序小循环结束************/

		
		CircleJudge*t = p;//指针t初始位置指向q的前驱节点
		//以当前排好序的节点为参照，进行非极大值抑制
		for (CircleJudge*q = p->next; q != NULL; )//后边的节点与待比较节点比较，q指向后面做比较的节点
		{
			int d_x = q->xx - p->xx;
			int d_y = q->yy - p->yy;
			int d_r = q->rr - p->rr;
			if (d_r*d_r <= square_min_radius_dist
				&& d_x*d_x + d_y*d_y <= square_min_center_dist)//不满足非极大值抑制条件
			{//删除结点过程
				t->next = q->next;
				delete q;
				q = t->next;
				ll--;//找到的圆数目-1
				continue;//此时q，p不需要移动
			}
			//t始终指向待删除节点的前驱节点
			t = t->next;
			q = q->next;
		}
		count++;//每循环一次排好序的元素就多了一个
	}



	//将结果返回到实参
	p = head->next;
	for (int i = 0; i < ll; i++)
	{
		if (i >= max_circle)
		{
			ll = max_circle;//找到的圆数量超过最大限制，则只返回max_circle个
			break;
		}
		x[i] = p->xx;
		y[i] = p->yy;
		radius[i] = p->rr;
		p = p->next;
	}
	*circle_cnt = ll;

	//找圆结果显示
#ifdef RES_SHOW
	int count_t = 0;
	for (p = head->next; p != NULL; p = p->next)
	{
		count_t++;
		cout << p->xx << "," << p->yy << "," << p->rr << "," << p->ave_max << endl;
	}
	cout << count_t << endl;
	cout << ll << endl;
#endif
	//释放内存空间
	for (p = head; p != NULL; )
	{
		head = head->next;
		delete p;
		p = head;
	}
	delete[] r_theta_xx;
	delete[] r_theta_yy;
	delete[] pixAve_b;
	delete[] pixAve_g;
	delete[] pixAve_r;

	return MY_OK;
}
